// Generated by CoffeeScript 1.10.0
var C, CELLS_HORIZONTAL, CELLS_VERTICAL, COUNT, CURRENT_CELL, EDGE_WALLS, HEIGHT, I, Ic, MAZE, RUNNING, Rchance, Rint, Rpick, TARGET_WALLS, WALL, WIDTH, blockCell, calcStraightLine, canvas, canvasToCellCoords, cellToCanvasCoords, cells, checkEdges, context, draw, drawCell, generateMaze, generateMazeStep, generateMazeSteps, i, inEdge, inMaze, inMazeAndWall, isRight, j, k, l, lastMouseCell, markCell, mouseDown, pixel, putPixel, ref, ref1, surroundingWalls, update;

Array.prototype.remove = function(element) {
  var index;
  index = this.indexOf(element);
  if (index !== -1) {
    return this.splice(index, 1);
  }
};

Rint = function(max, min) {
  if (max == null) {
    max = 1;
  }
  if (min == null) {
    min = 0;
  }
  return Math.floor(min + Math.random() * (max + 1 - min));
};

Rchance = function(percentage) {
  return Math.random() * 100 < percentage;
};

Rpick = function(list) {
  return list[int(list.length - 1)];
};

C = function(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
};

I = function(value, max, targetMax) {
  return (value / max) * targetMax;
};

Ic = function(value, max, targetMax) {
  var clamped;
  clamped = C(value, 0, max);
  return I(clamped, max, targetMax);
};


/*
=============================================================================
 */

calcStraightLine = function(point1, point2) {
  var coordinatesArray, dx, dy, e2, err, sx, sy, x1, x2, y1, y2;
  coordinatesArray = [];
  x1 = point1[0];
  y1 = point1[1];
  x2 = point2[0];
  y2 = point2[1];
  dx = Math.abs(x2 - x1);
  dy = Math.abs(y2 - y1);
  sx = x1 < x2 ? 1 : -1;
  sy = y1 < y2 ? 1 : -1;
  err = dx - dy;
  coordinatesArray.push([x1, y1]);
  while (!(x1 === x2 && y1 === y2)) {
    e2 = err << 1;
    if (e2 > -dy) {
      err -= dy;
      x1 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y1 += sy;
    }
    coordinatesArray.push([x1, y1]);
  }
  return coordinatesArray;
};


/*
=============================================================================
 */

WIDTH = 1500;

HEIGHT = 720;

CELLS_HORIZONTAL = WIDTH / 3;

CELLS_VERTICAL = HEIGHT / 3;

RUNNING = false;

WALL = 1;

MAZE = 2;

canvas = document.createElement('canvas');

context = canvas.getContext('2d');

canvas.width = WIDTH;

canvas.height = HEIGHT;

document.body.appendChild(canvas);

isRight = function(e) {
  e = e || window.event;
  if (e.which) {
    return e.which === 3;
  } else if (e.button) {
    return e.button === 2;
  }
  return false;
};

canvas.oncontextmenu = function(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  e.cancelBubble = true;
  return false;
};

lastMouseCell = void 0;

mouseDown = 0;

canvas.onmousedown = function(e) {
  console.log("mouse down", e.which, mouseDown);
  if (isRight(e)) {
    console.log("omhoog");
    ++mouseDown;
    lastMouseCell = canvasToCellCoords(e.offsetX, e.offsetY);
  }
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  e.cancelBubble = true;
  return false;
};

canvas.onmouseup = function(e) {
  console.log("mouse up", e.which, mouseDown);
  if (isRight(e)) {
    console.log("omlaag");
    --mouseDown;
    lastMouseCell = void 0;
  }
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  e.cancelBubble = true;
  return false;
};

canvasToCellCoords = function(x, y) {
  return [x === 0 ? 0 : Math.floor(x / 3), y === 0 ? 0 : Math.floor(y / 3)];
};

cellToCanvasCoords = function(x, y) {
  return [x * 3 + 1, y * 3 + 1];
};

blockCell = function(x, y) {
  var b, coords, g, r;
  cells[x][y] = MAZE;
  coords = cellToCanvasCoords(x, y);
  r = 100;
  g = 100;
  b = 100;
  putPixel(r, g, b, coords[0], coords[1]);
  putPixel(r, g, b, coords[0] + 1, coords[1]);
  putPixel(r, g, b, coords[0] + 1, coords[1] + 1);
  putPixel(r, g, b, coords[0], coords[1] + 1);
  putPixel(r, g, b, coords[0] - 1, coords[1] + 1);
  putPixel(r, g, b, coords[0] - 1, coords[1]);
  putPixel(r, g, b, coords[0] - 1, coords[1] - 1);
  putPixel(r, g, b, coords[0], coords[1] - 1);
  return putPixel(r, g, b, coords[0] + 1, coords[1] - 1);
};

canvas.addEventListener('mousemove', function(event) {
  var cell, i, j, k, l, len, line, m, point;
  if (mouseDown && lastMouseCell) {
    cell = canvasToCellCoords(event.offsetX, event.offsetY);
    if (inMaze(cell[0], cell[1])) {
      line = calcStraightLine(lastMouseCell, cell);
      for (k = 0, len = line.length; k < len; k++) {
        point = line[k];
        for (i = l = -1; l <= 1; i = ++l) {
          for (j = m = -1; m <= 1; j = ++m) {
            blockCell(point[0] + i, point[1] + j);
          }
        }
      }
      return lastMouseCell = cell;
    }
  }
}, false);

CURRENT_CELL = [];

TARGET_WALLS = [];

EDGE_WALLS = [];

canvas.addEventListener('click', function(event) {
  var cell, e, k, len, new_edge;
  cell = canvasToCellCoords(event.offsetX, event.offsetY);
  if (inMaze(cell[0], cell[1])) {
    markCell(cell, MAZE);
    new_edge = surroundingWalls(cell[0], cell[1]);
    for (k = 0, len = new_edge.length; k < len; k++) {
      e = new_edge[k];
      putPixel(0, 0, 255, e[0] * 3 + 1, e[1] * 3 + 1);
    }
    EDGE_WALLS = EDGE_WALLS.concat(new_edge);
    if (!RUNNING) {
      generateMazeSteps();
    }
  }
  if (event.stopPropagation) {
    event.stopPropagation();
  }
  event.cancelBubble = true;
  return false;
}, false);

cells = [];

for (i = k = 0, ref = CELLS_HORIZONTAL; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
  cells[i] = [];
  for (j = l = 0, ref1 = CELLS_VERTICAL; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
    cells[i][j] = WALL;
  }
}

pixel = context.getImageData(0, 0, 1, 1);

pixel.data[3] = 255;

putPixel = function(r, g, b, x, y) {
  pixel.data[0] = r;
  pixel.data[1] = g;
  pixel.data[2] = b;
  return context.putImageData(pixel, x, y);
};

draw = function() {
  var m, n, ref2, ref3;
  for (i = m = 0, ref2 = CELLS_HORIZONTAL; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
    for (j = n = 0, ref3 = CELLS_VERTICAL; 0 <= ref3 ? n < ref3 : n > ref3; j = 0 <= ref3 ? ++n : --n) {
      if (cells[i][j] === WALL) {
        putPixel(100, 100, 100, i, j);
      } else if (cells[i][j] === MAZE) {
        putPixel(255, 200, 100, i, j);
      } else {
        putPixel(0, 0, 255, i, j);
      }
    }
  }
  return true;
};

update = function() {
  context.clearRect(0, 0, canvas.width, canvas.height);
  return draw();
};

inMaze = function(x, y) {
  return x >= 0 && x < CELLS_HORIZONTAL && y >= 0 && y < CELLS_VERTICAL;
};

inMazeAndWall = function(x, y) {
  return inMaze(x, y) && cells[x][y] === WALL;
};

inEdge = function(x, y) {
  var e, len, m;
  for (m = 0, len = EDGE_WALLS.length; m < len; m++) {
    e = EDGE_WALLS[m];
    if (e[0] === x && e[1] === y) {
      return true;
    }
  }
  return false;
};

surroundingWalls = function(x, y, distance) {
  var walls;
  if (distance == null) {
    distance = 1;
  }
  walls = [];
  if (inMazeAndWall(x - 1, y) && !inEdge(x - 1, y) && Rchance(100)) {
    walls.push([x - 1, y, x, y, distance + 1]);
  }
  if (inMazeAndWall(x, y - 1) && !inEdge(x, y - 1) && Rchance(100)) {
    walls.push([x, y - 1, x, y, distance + 1]);
  }
  if (inMazeAndWall(x + 1, y) && !inEdge(x + 1, y) && Rchance(100)) {
    walls.push([x + 1, y, x, y, distance + 1]);
  }
  if (inMazeAndWall(x, y + 1) && !inEdge(x, y + 1) && Rchance(100)) {
    walls.push([x, y + 1, x, y, distance + 1]);
  }
  return walls;
};

markCell = function(cell, mark) {
  return cells[cell[0]][cell[1]] = mark;
};

COUNT = 0;

drawCell = function(cell) {
  var R, distance, dx, dy;
  COUNT += 1;
  distance = cell[4] || 0;
  R = (I(distance, 200, 255)) % 256;
  putPixel(R, 255, 255, cell[0] * 3 + 1, cell[1] * 3 + 1);
  if (cell[2] !== void 0 && cell[3] !== void 0) {
    dx = cell[2] - cell[0];
    dy = cell[3] - cell[1];
    putPixel(R, 200, 200, cell[0] * 3 + 1 + dx * 2, cell[1] * 3 + 1 + dy * 2);
    return putPixel(R, 200, 200, cell[0] * 3 + 1 + dx, cell[1] * 3 + 1 + dy);
  }
};

generateMaze = function() {
  var ANIMATED, e, len, m, results;
  CURRENT_CELL = [Rint(CELLS_HORIZONTAL), Rint(CELLS_VERTICAL)];
  markCell(CURRENT_CELL, MAZE);
  EDGE_WALLS = surroundingWalls(CURRENT_CELL[0], CURRENT_CELL[1]);
  for (m = 0, len = EDGE_WALLS.length; m < len; m++) {
    e = EDGE_WALLS[m];
    putPixel(0, 0, 255, e[0] * 3 + 1, e[1] * 3 + 1);
  }
  drawCell(CURRENT_CELL);
  ANIMATED = true;
  if (ANIMATED) {
    return generateMazeSteps();
  } else {
    results = [];
    while (EDGE_WALLS.length !== 0) {
      results.push(generateMazeStep());
    }
    return results;
  }
};

generateMazeSteps = function() {
  var m;
  if (EDGE_WALLS.length === 0) {
    RUNNING = false;
    return;
  }
  RUNNING = true;
  for (i = m = 0; m <= 100; i = ++m) {
    generateMazeStep();
  }
  return setTimeout(generateMazeSteps, 1);
};

generateMazeStep = function() {
  var e, len, m, new_edge, wall;
  if (EDGE_WALLS.length === 0) {
    RUNNING = false;
    return;
  }
  wall = EDGE_WALLS.splice(Rint(EDGE_WALLS.length - 1), 1)[0];
  drawCell(wall);
  CURRENT_CELL = wall;
  markCell(CURRENT_CELL, MAZE);
  new_edge = surroundingWalls(wall[0], wall[1], wall[4]);
  for (m = 0, len = new_edge.length; m < len; m++) {
    e = new_edge[m];
    putPixel(0, 0, 255, e[0] * 3 + 1, e[1] * 3 + 1);
  }
  return EDGE_WALLS = EDGE_WALLS.concat(new_edge);
};

checkEdges = function() {
  var e, len, m, results;
  results = [];
  for (m = 0, len = EDGE_WALLS.length; m < len; m++) {
    e = EDGE_WALLS[m];
    if (cells[e[0]][e[1]] === MAZE) {
      results.push(console.warn(e, "is maze"));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

context.clearRect(0, 0, canvas.width, canvas.height);

context.fillStyle = "rgb(50,50,50)";

context.fillRect(0, 0, WIDTH, HEIGHT);
