# fix array, because it sux
Array.prototype.remove = (element) ->

    index = @indexOf(element)
    if index != -1
        @splice index, 1

Rint = (max=1, min=0) ->
        return Math.floor(min + Math.random()*(max+1 - min))

Rchance = (percentage) ->
    return Math.random()*100 < percentage

Rpick = (list) ->
    return list[ int list.length-1 ]

C = (value, min, max) ->
    if(value < min) then return min
    if(value > max) then return max
    return value

I = (value, max, targetMax) -> # 4123, 5000, 255
    return (value / max) * targetMax

Ic = (value, max, targetMax) ->
    clamped = C value, 0, max
    return I clamped, max, targetMax



###
=============================================================================
###

calcStraightLine = (point1, point2) ->
    coordinatesArray = []
    # Translate coordinates
    x1 = point1[0]
    y1 = point1[1]
    x2 = point2[0]
    y2 = point2[1]
    # Define differences and error check
    dx = Math.abs(x2 - x1)
    dy = Math.abs(y2 - y1)
    sx = if x1 < x2 then 1 else -1
    sy = if y1 < y2 then 1 else -1
    err = dx - dy
    # Set first coordinates
    coordinatesArray.push([x1, y1])
    # Main loop
    while !(x1 == x2 and y1 == y2)
        e2 = err << 1
        if e2 > -dy
            err -= dy
            x1 += sx
        if e2 < dx
            err += dx
            y1 += sy
        # Set coordinates
        coordinatesArray.push([x1, y1])
    # Return the result
    return coordinatesArray

# ---
# generated by js2coffee 2.2.0


###
=============================================================================
###

# params
WIDTH = 1500
HEIGHT = 720
CELLS_HORIZONTAL = WIDTH/3
CELLS_VERTICAL = HEIGHT/3

RUNNING = false

# enum
WALL = 1
MAZE = 2


# init shizzle
canvas = document.createElement 'canvas'
context = canvas.getContext '2d'
canvas.width = WIDTH
canvas.height = HEIGHT
document.body.appendChild canvas

isRight = (e) ->
    e = e || window.event

#    debugger

    if e.which  # Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        return e.which == 3
    else if e.button  # IE, Opera
        return e.button == 2

    return false

canvas.oncontextmenu = (e) ->
    if (e.stopPropagation)
        e.stopPropagation()
    e.cancelBubble = true
    return false

lastMouseCell = undefined # used for drawing
mouseDown = 0
canvas.onmousedown = (e) ->
    console.log "mouse down", e.which, mouseDown
    if isRight e
        console.log "omhoog"
        ++mouseDown
        lastMouseCell = canvasToCellCoords e.offsetX, e.offsetY

    if (e.stopPropagation)
        e.stopPropagation()
    e.cancelBubble = true
    return false
canvas.onmouseup = (e) ->
    console.log "mouse up", e.which, mouseDown
    if isRight e
        console.log "omlaag"
        --mouseDown
        lastMouseCell = undefined

    if (e.stopPropagation)
        e.stopPropagation()
    e.cancelBubble = true
    return false


canvasToCellCoords = (x, y) ->
    return [
        if x==0 then 0 else Math.floor(x/3)
        if y==0 then 0 else Math.floor(y/3)
        ]


cellToCanvasCoords = (x, y) ->
    return [
        x*3+1
        y*3+1
        ]


blockCell = (x, y) ->
    cells[x][y] = MAZE

    coords = cellToCanvasCoords x, y

    r = 100
    g = 100
    b = 100

    putPixel(r, g, b, coords[0], coords[1])
    putPixel(r, g, b, coords[0]+1, coords[1])
    putPixel(r, g, b, coords[0]+1, coords[1]+1)
    putPixel(r, g, b, coords[0], coords[1]+1)
    putPixel(r, g, b, coords[0]-1, coords[1]+1)
    putPixel(r, g, b, coords[0]-1, coords[1])
    putPixel(r, g, b, coords[0]-1, coords[1]-1)
    putPixel(r, g, b, coords[0], coords[1]-1)
    putPixel(r, g, b, coords[0]+1, coords[1]-1)




canvas.addEventListener 'mousemove',  (event) ->
#    console.log event.offsetX, event.offsetY, event.button

    if mouseDown and lastMouseCell
        cell = canvasToCellCoords event.offsetX, event.offsetY

        if inMaze cell[0], cell[1]

            line = calcStraightLine lastMouseCell, cell

            for point in line
                # block a grid of 3x3
                for i in [-1..1]
                    for j in [-1..1]
                        blockCell(point[0]+i, point[1]+j)

            lastMouseCell = cell

, false

# starting point
CURRENT_CELL = []
TARGET_WALLS = []
EDGE_WALLS = []

canvas.addEventListener 'click',  (event) ->
#    console.log event.offsetX, event.offsetY, event.button

    cell = canvasToCellCoords event.offsetX, event.offsetY
#    console.log cell[0], cell[1]

    if inMaze cell[0], cell[1]

        markCell cell, MAZE

        new_edge = surroundingWalls cell[0], cell[1]
        for e in new_edge
            putPixel(0, 0, 255, e[0]*3+1, e[1]*3+1)
        EDGE_WALLS = EDGE_WALLS.concat new_edge

        # stopped, restart
        if not RUNNING
            generateMazeSteps()



    if (event.stopPropagation)
        event.stopPropagation()
    event.cancelBubble = true
    return false

, false



cells = []
for i in [0...CELLS_HORIZONTAL]
    cells[i] = []
    for j in [0...CELLS_VERTICAL]
        cells[i][j] = WALL

# pixels
pixel = context.getImageData(0, 0, 1, 1);
pixel.data[3] = 255
putPixel = (r, g, b, x, y) ->
    pixel.data[0] = r
    pixel.data[1] = g
    pixel.data[2] = b
    context.putImageData(pixel, x, y)

#    context.strokeStyle = "rgb("+Rint(255)+","+Rint(255)+","+Rint(255)+")"
#    context.strokeRect(x-50, y-50, 101, 101)

draw = () ->
    for i in [0...CELLS_HORIZONTAL]
        for j in [0...CELLS_VERTICAL]
            if cells[i][j] == WALL
                putPixel(100, 100, 100, i, j)
            else if cells[i][j] == MAZE
                putPixel(255, 200, 100, i, j)
            else
                putPixel(0, 0, 255, i, j)

#            putPixel(
#                Math.floor(Math.random() * i) % 255,
#                Math.floor(Math.random() * j) % 255,
#                Math.floor(Math.random() * (i+j)) % 255,
#                i, j
#            )
    return true

# update loop
update = () ->
    context.clearRect 0, 0, canvas.width, canvas.height
    draw()
#    window.requestAnimationFrame update



inMaze = (x, y) ->
    return x >= 0 and x < CELLS_HORIZONTAL and y >= 0 and y < CELLS_VERTICAL

inMazeAndWall = (x, y) ->
    return inMaze(x, y) and cells[x][y] == WALL

inEdge = (x, y) ->
    for e in EDGE_WALLS
        if e[0] == x and e[1] == y
            return true
    return false

surroundingWalls = (x, y, distance=1) ->
    walls = []
    # left
    if inMazeAndWall(x-1, y) and not inEdge(x-1, y) and Rchance 100
        walls.push [x-1, y, x, y, distance+1]
    # up
    if inMazeAndWall(x, y-1) and not inEdge(x, y-1)  and Rchance 100
        walls.push [x, y-1, x, y, distance+1]
    # right
    if inMazeAndWall(x+1, y) and not inEdge(x+1, y) and Rchance 100
        walls.push [x+1, y, x, y, distance+1]
    # down
    if inMazeAndWall(x, y+1) and not inEdge(x, y+1) and Rchance 100
        walls.push [x, y+1, x, y, distance+1]

#    if inMazeAndWall(x-1, y-1) and not inEdge(x-1, y-1)
#        walls.push [x-1, y-1, x, y]
#    if inMazeAndWall(x-1, y+1) and not inEdge(x-1, y+1)
#        walls.push [x-1, y+1, x, y]
#    if inMazeAndWall(x+1, y+1) and not inEdge(x+1, y+1)
#        walls.push [x+1, y+1, x, y]
#    if inMazeAndWall(x+1, y-1) and not inEdge(x+1, y-1)
#        walls.push [x+1, y-1, x, y]
    return walls

markCell = (cell, mark) ->
    cells[cell[0]][cell[1]] = mark

COUNT = 0
drawCell = (cell) ->
    COUNT+=1


    distance = cell[4] || 0
    R = (I distance, 200, 255)%256

    putPixel(R, 255, 255, cell[0]*3+1, cell[1]*3+1)
    if cell[2] != undefined and cell[3] != undefined

        dx = cell[2] - cell[0]
        dy = cell[3] - cell[1]

        putPixel(R, 200, 200, cell[0]*3+1+dx*2, cell[1]*3+1+dy*2)
        putPixel(R, 200, 200, cell[0]*3+1+dx, cell[1]*3+1+dy)


generateMaze = () ->

#    CURRENT_CELL = [0, Rint CELLS_VERTICAL]
    CURRENT_CELL = [Rint(CELLS_HORIZONTAL), Rint(CELLS_VERTICAL)]
    markCell CURRENT_CELL, MAZE
    EDGE_WALLS = surroundingWalls CURRENT_CELL[0], CURRENT_CELL[1]

    for e in EDGE_WALLS
        putPixel(0, 0, 255, e[0]*3+1, e[1]*3+1)

    drawCell CURRENT_CELL


    ANIMATED = true
    if ANIMATED
        generateMazeSteps()
    else
        while EDGE_WALLS.length != 0
            generateMazeStep()

generateMazeSteps = () ->

    if EDGE_WALLS.length == 0
        RUNNING = false
        return

    RUNNING = true

    for i in [0..100]
        generateMazeStep()

    setTimeout(generateMazeSteps, 1)

generateMazeStep = () ->

    if EDGE_WALLS.length == 0
        RUNNING = false
        return

    # generate new bloxk
    wall = EDGE_WALLS.splice(Rint(EDGE_WALLS.length-1), 1)[0]

#    putPixel(255, 255, 255, wall[0], wall[1])
    drawCell wall

    # new edge
    CURRENT_CELL = wall
    markCell CURRENT_CELL, MAZE

    new_edge = surroundingWalls wall[0], wall[1], wall[4]
    for e in new_edge
        putPixel(0, 0, 255, e[0]*3+1, e[1]*3+1)
    EDGE_WALLS = EDGE_WALLS.concat new_edge

checkEdges = () ->

    for e in EDGE_WALLS
        if cells[e[0]][e[1]] == MAZE
            console.warn e, "is maze"


context.clearRect 0, 0, canvas.width, canvas.height
context.fillStyle = "rgb(50,50,50)"
context.fillRect 0,0,WIDTH,HEIGHT

#generateMaze()
#update()

